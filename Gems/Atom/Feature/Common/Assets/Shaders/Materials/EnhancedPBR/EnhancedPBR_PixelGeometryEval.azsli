/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

// This #define magic lets you use the EvaluatePixelGeometry function in this file without making it the final EvaluatePixelGeometry
// used in your shader. Simply #define EvaluatePixelGeometry to your custom definition before including this file
//
#ifndef EvaluatePixelGeometry
#define EvaluatePixelGeometry(IN, isFrontFace, instanceId)      EvaluatePixelGeometry_EnhancedPBR(IN, isFrontFace, instanceId)
#endif

#include "../StandardPBR/StandardPBR_PixelGeometryEval.azsli"

#include <Atom/Features/Debug.azsli>

PixelGeometryData EvaluatePixelGeometry_EnhancedPBR(
    inout float4 positionSV,
    float3 positionWS,
    float3 normal,
    float3 tangent,
    float3 bitangent,
    float2 uvs[UvSetCount],
    float2 detailUvs[UvSetCount],
    bool isFrontFace,
    uint instanceId)
{
    PixelGeometryData geoData = EvaluatePixelGeometry_BasePBR(positionWS, normal, tangent, bitangent, uvs, isFrontFace);

    // ------- Detail UVs -------

    geoData.detailUvs = detailUvs;

    // ------- Parallax -------

    geoData.isDisplacementClipped = false;

    if(ShouldHandleParallax())
    {
        SetPixelDepth(geoData.positionWS, geoData.vertexNormal, geoData.tangents, geoData.bitangents,
                      geoData.uvs, geoData.detailUvs, isFrontFace, positionSV.z, positionSV.w, instanceId, geoData.isDisplacementClipped);
    }

    return geoData;
}

PixelGeometryData EvaluatePixelGeometry_EnhancedPBR(inout VsOutput IN, bool isFrontFace, uint instanceId)
{
    // TODO: We're duplicating the work of getting the world matrix here and in the call to SetPixelDepth.
    // We should add an overload of SetPixelDepth that takes the world transform as input, and use that instead of
    // passing the instanceId all the way through
    float4x4 objectToWorld = DrawSrg::GetWorldMatrix(instanceId);
    float3x3 objectToWorldIT = DrawSrg::GetWorldMatrixInverseTranspose(instanceId);

    float3 vertexNormal, vertexTangent, vertexBitangent;
    ConstructTBN(IN.normal, IN.tangent, objectToWorld, objectToWorldIT, vertexNormal, vertexTangent, vertexBitangent);

    return EvaluatePixelGeometry_EnhancedPBR(
        IN.position,
        IN.worldPosition,
        vertexNormal,
        vertexTangent,
        vertexBitangent,
        IN.uvs,
        IN.detailUvs,
        isFrontFace,
        instanceId);
}
