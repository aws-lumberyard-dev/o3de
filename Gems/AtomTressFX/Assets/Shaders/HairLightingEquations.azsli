/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/

#pragma once

// --- Overview ---
// 
// This is a modified Marschner Lighting Model for hair based on the following papers:
// 
// The original Marschner Siggraph paper defining the fundementsal hair lighting model.
// http://www.graphics.stanford.edu/papers/hair/hair-sg03final.pdf
// 
// An Energy-Conserving Hair Reflectance Model
// http://www.eugenedeon.com/project/an-energy-conserving-hair-reflectance-model/
// http://www.eugenedeon.com/wp-content/uploads/2014/04/egsrhair.pdf
// 
// Physically Based Hair Shading in Unreal - specifically adapted in our shader
// https://blog.selfshadow.com/publications/s2016-shading-course/karis/s2016_pbs_epic_hair.pptx
// 
// Strand-based Hair Rendering in Frostbite for reference
// https://advances.realtimerendering.com/s2019/hair_presentation_final.pdf
// 
// 
// The Marschner model divides hair rendering into three light paths: R, TT and TRT 
// R - the light bounces straight off the hair fiber (Reflection)
// TT - the light penetrates the hair fiber and exits at the other side (Transmitance - Transmitance)
// TRT - the light penetrates the hair fiber, bounces inside and exists (Transmitance - Reflection - Transmitance)
// 
// For each path, the calculations are devided into longitudinal and azimuthal approximations 
// denoted M and N respectively and named: M_R, M_TT, M_TRT  and  N_R, N_TT, N_TRT.

// --- Notations ---
// 
// Wi - incoming light vector 
// Wr - reflected light vector
// L - angles with respect to the Longitude
// O - vectors with respect to the azimuth
// Li and Lr are the longitudinal angles with respect to incoming/reflected light, i.e. the angle between 
//      those vector and the normal plane (plane perpendicular to the hair)
// Oi and Or are the azimuthal angles, i.e. the angles contained by the normal plane
// Lh and Oh are the averages, i.e. Lh = (Lr + Li) / 2  and  Oh = (Or + Oi) / 2
// Ld is the difference angle, i.e. Ld = (Lr - Li) / 2
// O denotes the relative azimuth, simply O = (Or - Oi)

#include <Atom/RPI/Math.azsli>

//------------------------------------------------------------------------------
option bool o_enableMarschner_R = true;
option bool o_enableMarschner_TRT = true;
option bool o_enableMarschner_TT = true;

option bool o_enableDiffuseLobe = true; // Azimutal - debug mode
option bool o_enableSpecularLobe = true;// longtitude - debug mode
option bool o_enableTransmittanceLobe = true;
//------------------------------------------------------------------------------

// Longitudinal functions (M_R, M_TT, M_RTR)
// Notice that tilt and roughness multipliers are a-priori per Epic artistic taste 
float M_R(Surface surface, float Lh, float sinLiPlusSinLr)
{
    float a = 1.0f * surface.cuticleTilt;   // Tilt is translate as the mean offset
    float b = 0.5 * surface.roughnessA2;    // Roughness is used as the standard deviation

//    return GaussianNormalized(sinLiPlusSinLr, a, b);
    return GaussianNormalized(Lh, a, b);
}

float M_TT(Surface surface, float Lh, float sinLiPlusSinLr)
{
    float a = 1.0 * surface.cuticleTilt;
    float b = 0.5 * surface.roughnessA2;
//    return GaussianNormalized(sinLiPlusSinLr, a, b);
    return GaussianNormalized(Lh, a, b);
}

float M_TRT(Surface surface, float Lh, float sinLiPlusSinLr)
{
    float a = 1.5 * surface.cuticleTilt;
    float b = 1.0 * surface.roughnessA2;

    // Reference functions 
//    return GaussianNormalized(sinLiPlusSinLr, a, b);
//    return M_R_Marschner(Lh, a, b);
    return GaussianNormalized(Lh, a, b);    
}


// Azimuth functions (N_R, N_TT, N_RTR)
float N_R(Surface surface, float cos_O2, float3 Wi, float3 Wr, float f0)
{
    // Fresnel part of the attentuation term (A in the papers)
    float fresnel = FresnelSchlick( sqrt(0.5 * dot(Wi, Wr) + 0.5) , f0);

    // Distribution term
    float distribution = 0.25 * cos_O2;

    // No absorption term since this is the reflected light path
    return fresnel * distribution;
}

// Light passes through the hair and exits at the back - most dominant effect
// will be of lights at the back of the hair when the hair is thin and not concealed 
float3 N_TT(Surface surface, float n2, float cos_O, float cos_O2, float3 cos_Ld, float f0)
{
    // Helper variables (see papers)
    float a = rcp(n2);  // OK
    float h = (1 + a * (0.6 - (0.8 * cos_O))) * cos_O2; // OK

    // Fresnel part of the attentuation term (A in the papers)
    float fresnel = FresnelSchlick(cos_Ld * sqrt( 1 - (h*h) ), f0);
    fresnel = Pow2(1 - fresnel);

    // The absorption part of the attenuation term (A in the papers).
    float3 absorption = pow(surface.albedo, sqrt( 1 - (h*h*a*a) ) / (2 * cos_Ld) );

    // Distribution term
    float distribution = exp(-3.65 * cos_O - 3.98);

    return absorption * (fresnel * distribution);
}

float3 N_TRT(Surface surface, float cos_O, float3 cos_Ld, float f0)
{
    // Helper variables (see papers)
    float h = sqrt(3.0f) * 0.5f;

    // Fresnel part of the attentuation term (A in the papers)
    float fresnel = FresnelSchlick(cos_Ld * sqrt( 1 - (h*h) ), f0);
    fresnel = Pow2(1 - fresnel) * fresnel;

    // How much light the hair will absorb. Part of the attenuation term (A in the papers)
    float3 absorption = pow(surface.albedo, 0.8f / max(cos_Ld, 0.001) ); // [To Do] Adi: verify correctness of bound

    // Distribution term
    float distribution = exp(17.0f * cos_O - 16.78f);

    return absorption * (fresnel * distribution);
}


float3 HairBSDF(Surface surface, LightingData lightingData, const float3 dirToLight)
{
    // Incoming and outgoing light directions
    float3 Wi = normalize(dirToLight);                 // Incident light direction
    float3 Wr = normalize(lightingData.dirToCamera);   // Reflected light measurement direction AKA reflection

    // Hair tangent
    float3 T = surface.tangent;

    // The incident light and reflection directions projected along the tangent
    float Ti = T * dot(T, Wi);
    float Tr = T * dot(T, Wr);

    // The light and reflection vectors projected along the normal plane to the hair.
    // This plane is used for separating the Azimuth and Longtitude angles and vectors.
    float3 NPi = normalize(Wi - Ti);
    float3 NPr = normalize(Wr - Tr);

    // Azimuthal angle between the incident light vector and the reflection 
    // direction (the direction at which we measure the light scaterring)
    // float O = acos(dot(NPi, NPr))  <- Unused, for reference only
    float cos_O = dot(NPi, NPr);

    // cosine(O / 2)
    float cos_O2 = sqrt(0.5 * cos_O + 0.5);  // <- trigonometric formula for calculating cos(x/2) given cos(x) 

    // Longitudinal angles
    float Li = acos(clamp(dot(Wi, NPi),-1.0, 1.0));
    float Lr = acos(clamp(dot(Wr, NPr),-1.0, 1.0));
    float Lh = (Lr + Li) * 0.5;
    float Ld = (Lr - Li) * 0.5;
//    float sinLiPlusSinLr = dot(Wi, NPi) * dot(Wr, NPr);// sin(Li) + sin(Lr);
    float sinLiPlusSinLr = sin(Li) + sin(Lr);

    // Refraction index 
    const float n = 1.55;
    float cos_Ld = cos(Ld);
    float n2 = (1.19f / cos_Ld) + 0.36f * cos_Ld;

    // Fresnel F0
    float f0 = Pow2( (1 - n) / (1 + n) );

    float3 lighting = float3(0, 0, 0);

    // R Path - single reflection from the hair towards the eye.
    if (o_enableMarschner_R)
    {
        float lighting_R = o_enableDiffuseLobe ? M_R(surface, Lh, sinLiPlusSinLr) : float3(1, 1, 1);
        if (o_enableSpecularLobe)
            lighting_R *= N_R(surface, cos_O2, Wi, Wr, f0);

        // The following lines are a cheap method to get occluded reflection by accoounting 
        // for the thickness if the reflection of light is going through the hair.
        // A reminder for this approximation - this is the R and not the TT lobe.
//        float lightToEye = smoothstep(0.0, 0.6, -dot(Wi, Wr));
        float lightToEye = saturate(-dot(Wi, Wr));
        float selfOcclude = lightToEye * surface.thickness;
        float lightTransferRatio = 1.0f - selfOcclude;
        lightTransferRatio *= lightTransferRatio;
//        lighting_R *= lightTransferRatio;

        lighting += float3(lighting_R, lighting_R, lighting_R);// +float3(0.1, 0.05, 0);
    }

    // TT Path - ray passes through the hair.
    // The ray from the eye is refracted into the hair, then refracted again through the 
    // back of the hair.  The main contribution here would for thin hair areas from lights 
    // behind the hair that are not concealed.
    if (o_enableMarschner_TT)
    {   
        float3 lighting_TT = o_enableDiffuseLobe ? M_TT(surface, Lh, sinLiPlusSinLr) : float3(1, 1, 1);
        if (o_enableSpecularLobe)
            lighting_TT *= N_TT(surface, n2, cos_O, cos_O2, cos_Ld, f0);

        // Reduce back transmittance based on the thicknessof the hair
        lighting_TT *= (1.0f - surface.thickness);
        lighting += lighting_TT;// +float3(0, 0.1, 0);
    }

    // RTR Path - ray refracted into the hair, then reflected back and exits 
    // the hair towards the eye.
    if (o_enableMarschner_TRT)
    {
        float3 lighting_TRT = o_enableDiffuseLobe ? M_TRT(surface, Lh, sinLiPlusSinLr) : float3(1, 1, 1);
        if (o_enableSpecularLobe)
            lighting_TRT *= N_TRT(surface, cos_O, cos_Ld, f0);
        lighting += lighting_TRT;// +float3(0.2, 0, 0.5);
    }

    if (!o_enableMarschner_R && !o_enableMarschner_TT && !o_enableMarschner_TRT)
    {
        if (o_enableDiffuseLobe)
        {
//            lighting += T;// *0.5 + 0.5;    // effected - not clear that immediate!!!

            if (isnan(Lr))
                lighting = float3(0.5, 1.0, 0.5);    // Main event!!!
            else if (isinf(Lr))
                lighting = float3(1.0, 0, 1.0);    // Main event!!!
            else
                lighting = float3(2.0 * Lr/PI, 0, 0);    // effected - not clear that immediate!!!

                //            lighting += float3(Lr/1.57, 0, 0);    // effected - not clear that immediate!!!
                //            lighting += float3(n2, 0, 0);     // Affected - same pattern
                //            lighting += float3(Lh, 0, 0);     // No effect - as expected
        }


        if (o_enableSpecularLobe)
        {
            /*
            if (Li < -1.57)
                lighting += float3(1, 0, 1);    // Main event!!!
            else if (Li < 0)
                lighting += float3(0, 0, 1);    // Main event!!!
//            else if (isnan(Li))
//                lighting += float3(1,1,1);    // Main event!!!
            else
            */
            float halfPi = 0.5 * PI;
            if (isnan(Li))
                lighting = float3(1.0, 0, 0.0);    // Main event!!!
            else if (isinf(Li))
                lighting = float3(1.0, 1.0, 1.0);    // Main event!!!
            else
                lighting = float3(0, Li / PI, 0);    // Main event!!!
                                                       //            if (isnan(Li))
//                lighting += float3(1, 0, 0);
//            else
//                lighting += float3(0, Li, 0.0);    // Animate it and you'd see the pattern
            //            lighting += float3(0, cos_O, 0);    // No efect
            //            lighting += float3(0, (1.57 + Ld) / 1.57, 0.05);    // same pattern
        }

        if (o_enableTransmittanceLobe)
        {
            if (isnan(cos_Ld))
                lighting = float3(0.0, 1.0, 0.0);    // Main event!!!
            else if (isinf(cos_Ld))
                lighting = float3(1.0, 1.0, 1.0);    // Main event!!!
            else
                lighting = float3(0, 0, cos_Ld);   // Direct effect
        }
    }

    return lighting;
}
