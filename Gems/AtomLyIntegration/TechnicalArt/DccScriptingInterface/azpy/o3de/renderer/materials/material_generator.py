# coding:utf-8
#!/usr/bin/python
#
# Copyright (c) Contributors to the Open 3D Engine Project.
# For complete copyright and license terms please see the LICENSE at the root of this distribution.
#
# SPDX-License-Identifier: Apache-2.0 OR MIT
#
#
# -------------------------------------------------------------------------

"""! @brief This script when called will export an all properties dictionary for the value passed to the first
 argument (material type). The second value is a boolean that allows you to either use the most current
 values, generated at runtime from our materialtype files from which the material editor sources, or to just
 leverage previously generated files that have been saved to the DCCsi codebase. The default is set to True. """

from pathlib import Path
from box import Box
import logging as logging
from azpy.o3de.utils import o3de_utilities as o3de_helpers


_LOGGER = logging.getLogger('DCCsi.azpy.o3de.renderer.materials.material_generator')


class MaterialGenerator:
    def __init__(self, **kwargs):

        self.material_type_dictionary = {}
        self.material_type = kwargs['material_type']
        self.material_textures = kwargs['material_textures']
        self.material_name = kwargs['material_name']
        self.start_directory = Path(kwargs['start_directory'])
        self.destination_directory = Path(kwargs['destination_directory'])
        self.dccsi_path = kwargs['dccsi_path']
        self.repo_path = kwargs['repo_path']
        self.template_source_directory = Path(self.repo_path) / 'Gems/Atom/Feature/Common/Assets/Materials/Types'
        self.material_template_path = self.get_material_definition_path(self.template_source_directory)
        self.material_type_definitions = [x for x in self.template_source_directory.glob('*.materialtype')]
        self.material_templates_directory = Path(self.dccsi_path) / 'azpy/o3de/renderer/materials'
        self.material_definition = Box({
            'description': 'Material Definition generated by the Digital Content Creation Scripting Interface (DCCsi)',
            'materialType': 'Materials/Types/StandardPBR.materialtype',
            'materialTypeVersion': '5',
            'propertyValues': {}
        })

    def create_material_definition(self):
        properties_dictionary = Box({})
        relative_path = self.get_relative_path()
        for texture_type, texture_path in self.material_textures.items():
            texture_path = (Path(relative_path) / 'textures' / Path(texture_path).name).as_posix()
            if texture_type == 'color' or texture_type == 'baseColor':
                properties_dictionary['baseColor.textureBlendMode'] = 'Lerp'
                properties_dictionary['baseColor.textureMap'] = texture_path
            elif texture_type == 'emissionColor':
                properties_dictionary['emissive.color'] = [1.0, 1.0, 1.0, 1.0]
                properties_dictionary['emissive.enable'] = True
                properties_dictionary['emissive.intensity'] = 4
                properties_dictionary['emissive.textureMap'] = texture_path
            elif texture_type == 'metallic':
                properties_dictionary['metallic.textureMap'] = texture_path
            elif texture_type == 'normal':
                properties_dictionary['normal.textureMap'] = texture_path
            elif texture_type == 'occlusion':
                properties_dictionary['occlusion.diffuseTextureMap'] = texture_path
            elif texture_type == 'opacity':
                properties_dictionary['opacity.factor'] = 1.0
                properties_dictionary['opacity.mode'] = 'Cutout'
                properties_dictionary['opacity.textureMap'] = texture_path
            elif texture_type == 'height':
                properties_dictionary['parallax.textureMap'] = texture_path
            elif texture_type == 'roughness':
                properties_dictionary['roughness.textureMap'] = texture_path
            elif texture_type == 'specular':
                properties_dictionary['specularF0.textureMap'] = texture_path

        if properties_dictionary:
            self.material_definition['propertyValues'] = properties_dictionary
            output_path = self.destination_directory / self.material_name
            o3de_helpers.export_o3de_material(output_path, self.material_definition)
            return output_path.as_posix()
        return None

    def get_relative_path(self):
        target_directory = self.start_directory.name
        path_parts = self.destination_directory.parts
        target_index = path_parts.index(target_directory) + 1
        return Path('/'.join(path_parts[target_index:]))

    def read_template_properties(self):
        """!
        For basing material creation on existing O3DE Templates, you will need to build on this function. For now,
        this is really overkill to create materials based on existing texture sets, but you will want to work on
        this over time to handle textures dynamically, as well as considering attribute values in addition to textures
        """
        material_template_path = self.get_material_definition_path(self.template_source_directory)
        material_template = self.get_material_json(material_template_path)
        _LOGGER.info(f'MaterialName [{self.material_name}]   MaterialTemplate: {material_template}')

    def get_material_definition_path(self, base_directory):
        try:
            for file in base_directory.iterdir():
                filename = file.name.lower()
                if filename.startswith(self.material_type.lower()) and filename.endswith('.materialtype'):
                    return file
        except IndexError:
            return None

    def get_material_json(self, target_path):
        with open(target_path) as material_json:
            data = material_json.read()
            return data
