/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/

#include <scenesrg.srgi>

#define TILE_DIM_X 16
#define TILE_DIM_Y 16

ShaderResourceGroup PassSrg : SRG_PerPass
{
    Texture2D<float4> m_inputColor;
    RWTexture2D<float4> m_outputColor;

    float m_strength; // Strength of the sharpening effect. Range from 0 to 1.
}


// Constrast Adaptive Sharpening, based on AMD FidelityFX CAS - https://gpuopen.com/fidelityfx-cas/

// This shader sharpens the input based on the contrast of the local neighborhood
// so that only areas that need sharpening are sharpened, while high constast areas
// are mostly left alone.

[numthreads(TILE_DIM_X, TILE_DIM_Y, 1)]
void MainCS(
    uint3 dispatchThreadID : SV_DispatchThreadID, 
    uint3 groupID : SV_GroupID, 
    uint groupIndex : SV_GroupIndex)
{
    uint2 pixelCoord = dispatchThreadID.xy;

    // Fetch local neighborhood to determin sharpening weight.
    //   a
    // b c d
    //   e

    float3 sampleA = PassSrg::m_inputColor[pixelCoord + int2( 0, -1)].rgb;
    float3 sampleB = PassSrg::m_inputColor[pixelCoord + int2(-1,  0)].rgb;
    float3 sampleC = PassSrg::m_inputColor[pixelCoord + int2( 0,  0)].rgb;
    float3 sampleD = PassSrg::m_inputColor[pixelCoord + int2( 1,  0)].rgb;
    float3 sampleE = PassSrg::m_inputColor[pixelCoord + int2( 0,  1)].rgb;

    // Get the min and max. Just use the green channel for luminance.
    float minG = min(min(sampleA.g, sampleB.g), min(sampleC.g, min(sampleD.g, sampleE.g)));
    float maxG = max(max(sampleA.g, sampleB.g), max(sampleC.g, max(sampleD.g, sampleE.g)));

    float dMinG = minG; // Distance from 0 to minimum
    float dMaxG = 1.0 - maxG; // Distance from 1 to the maximum

    // baseSharpening is higher when local contrast is lower to avoid over-sharpening.
    float baseSharpening = min(dMinG, dMaxG) / max(maxG, 0.0001);
    baseSharpening = sqrt(baseSharpening); // bias towards more sharpening

    float developerMaximum = lerp(-0.125, -0.2, PassSrg::m_strength);
    float weight = baseSharpening * developerMaximum;
    float totalWeight = weight * 4 + 1.0;

    float3 output =
    (
        sampleA * weight +
        sampleB * weight +
        sampleC          +
        sampleD * weight +
        sampleE * weight
    ) / totalWeight;

    PassSrg::m_outputColor[pixelCoord] = float4(output, 1.0);
}
