/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/

#include <scenesrg.srgi>
#include <Atom/Features/PostProcessing/PostProcessUtil.azsli>

#define TILE_DIM_X 16
#define TILE_DIM_Y 16

ShaderResourceGroup PassSrg : SRG_PerPass
{
    Texture2D<float4> m_inputColor;
    Texture2D<float4> m_inputDepth;
    RWTexture2D<float4> m_outputColor;
    Texture2D<float2> m_motionVectors;
    Texture2D<float4> m_lastFrameAccumulation;

    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Clamp;
        AddressV = Clamp;
        AddressW = Clamp;
    };

    float m_minContribution;

    struct Constants
    {
        uint2 m_size;
    };
    Constants m_constantData;
}

// Do fancy LDS stuff after initial implementation works.
/*
groupshared float3 shared_samples[(TILE_DIM_X + 2) * (TILE_DIM_Y + 2)];
groupshared float shared_depth[(TILE_DIM_X + 2) * (TILE_DIM_Y + 2)];
*/

[numthreads(TILE_DIM_X, TILE_DIM_Y, 1)]
void MainCS(
    uint3 dispatchThreadID : SV_DispatchThreadID, 
    uint3 groupID : SV_GroupID, 
    uint groupIndex : SV_GroupIndex)
{
    // Get color / depth / motion for current frame.
    uint2 pixelCoord = dispatchThreadID.xy;
    float3 color = PassSrg::m_inputColor[pixelCoord].rgb;
    float depth = PassSrg::m_inputDepth[pixelCoord].r;
    float2 previousPosition = -PassSrg::m_motionVectors[pixelCoord];

    // NaN protection (without this NaNs could get in the history buffer and quickly consume the frame)
    color = max(0.0, color);

    // Tonemap color
    float luminance = GetLuminance(color);
    color = color / (1.0 + luminance);

    // Get the uv coordinate for the previous frame.
    uint2 size = PassSrg::m_constantData.m_size;
    float2 halfPixel = rcp(size * 2.0);
    float2 uvCoord = pixelCoord / float2(size) + halfPixel;
    float2 uvOld = float2(uvCoord) + previousPosition;

    // For now just rely on hardware bilinear filtering but this is something that will be improved.
    // Color in rgb, Depth in a
    float4 lastFrameColorDepth = PassSrg::m_lastFrameAccumulation.SampleLevel(PassSrg::LinearSampler, uvOld, 0.0);

    // Tonemap last frame color
    lastFrameColorDepth.rgb = lastFrameColorDepth / (1.0 + luminance);

    float weight = PassSrg::m_minContribution;

    // Basic depth rejection
    if (abs(depth - lastFrameColorDepth.a) > 0.001)
    {
        weight = 1.0f;
    }

    // Out of bounds protection.
    if (any(uvOld > 1.0) || any(uvOld < 0.0))
    {
        weight = 1.0f;
    }

    // Blend color with history
    color = lerp(lastFrameColorDepth.rgb, color, weight);

    // Un-tonemap color
    color = color * (1.0 + luminance);

    PassSrg::m_outputColor[pixelCoord].rgb = color;

    // Output depth to check against next frame. This is much higher precision than necessary for a depth rejection, so we'll either move this to a
    // separate buffer or stuff some additional data useful to taa in the same spot.
    PassSrg::m_outputColor[pixelCoord].a = depth;
    
}
