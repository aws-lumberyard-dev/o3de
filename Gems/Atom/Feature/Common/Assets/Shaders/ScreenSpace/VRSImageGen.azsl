/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#include <scenesrg.srgi>

ShaderResourceGroup PassSrg : SRG_PerPass
{
    
    Texture2D<float2> m_motionVectors;
    Texture2D<float4>   m_previousFrame;
    RWTexture2D<uint>   m_outputTexture;
    
    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Clamp;
        AddressV = Clamp;
        AddressW = Clamp;
    };

   
    //int2 g_Resolution;
    //uint g_TileSize;
    float g_VarianceCutoff;
    float g_MotionFactor;
}


// read a value from previous frames color buffer and return luminance
float FFX_VariableShading_ReadLuminance(int2 pos)
{
    float3 color = PassSrg::m_previousFrame[pos].xyz;

    // return color value converted to grayscale
    return dot(color, float3(0.30, 0.59, 0.11));

    // in some cases using different weights, linearizing the color values 
    // or multiplying luminance with a value based on specularity or depth
    // may yield better results
}

// read per pixel motion vectors and convert them to pixel-space
float2 FFX_VariableShading_ReadMotionVec2D(int2 pos)
{
    int2 g_Resolution = int2(1711, 941);
    // return 0 to not use motion vectors
    return PassSrg::m_motionVectors[pos].xy * float2(0.5f, -0.5f) * g_Resolution;
}

void FFX_VariableShading_WriteVrsImage(int2 pos, uint value)
{
    PassSrg::m_outputTexture[pos] = value;
}

static const uint FFX_VARIABLESHADING_RATE1D_1X = 0x0;
static const uint FFX_VARIABLESHADING_RATE1D_2X = 0x1;
static const uint FFX_VARIABLESHADING_RATE1D_4X = 0x2;
#define FFX_VARIABLESHADING_MAKE_SHADING_RATE(x,y) ((x << 2) | (y))

static const uint FFX_VARIABLESHADING_RATE_1X1 = FFX_VARIABLESHADING_MAKE_SHADING_RATE(FFX_VARIABLESHADING_RATE1D_1X, FFX_VARIABLESHADING_RATE1D_1X); // 0;
static const uint FFX_VARIABLESHADING_RATE_1X2 = FFX_VARIABLESHADING_MAKE_SHADING_RATE(FFX_VARIABLESHADING_RATE1D_1X, FFX_VARIABLESHADING_RATE1D_2X); // 0x1;
static const uint FFX_VARIABLESHADING_RATE_2X1 = FFX_VARIABLESHADING_MAKE_SHADING_RATE(FFX_VARIABLESHADING_RATE1D_2X, FFX_VARIABLESHADING_RATE1D_1X); // 0x4;
static const uint FFX_VARIABLESHADING_RATE_2X2 = FFX_VARIABLESHADING_MAKE_SHADING_RATE(FFX_VARIABLESHADING_RATE1D_2X, FFX_VARIABLESHADING_RATE1D_2X); // 0x5;
static const uint FFX_VARIABLESHADING_RATE_2X4 = FFX_VARIABLESHADING_MAKE_SHADING_RATE(FFX_VARIABLESHADING_RATE1D_2X, FFX_VARIABLESHADING_RATE1D_4X); // 0x6;
static const uint FFX_VARIABLESHADING_RATE_4X2 = FFX_VARIABLESHADING_MAKE_SHADING_RATE(FFX_VARIABLESHADING_RATE1D_4X, FFX_VARIABLESHADING_RATE1D_2X); // 0x9;
static const uint FFX_VARIABLESHADING_RATE_4X4 = FFX_VARIABLESHADING_MAKE_SHADING_RATE(FFX_VARIABLESHADING_RATE1D_4X, FFX_VARIABLESHADING_RATE1D_4X); // 0xa;



static const uint FFX_VariableShading_ThreadCount1D_1 = 8;
static const uint FFX_VariableShading_NumBlocks1D_1 = 1;
static const uint FFX_VariableShading_SampleCount1D_1 = FFX_VariableShading_ThreadCount1D_1 + 2;

groupshared uint FFX_VariableShading_LdsGroupReduce_1;

static const uint FFX_VariableShading_ThreadCount_1 = FFX_VariableShading_ThreadCount1D_1 * FFX_VariableShading_ThreadCount1D_1;
static const uint FFX_VariableShading_SampleCount_1 = FFX_VariableShading_SampleCount1D_1 * FFX_VariableShading_SampleCount1D_1;
static const uint FFX_VariableShading_NumBlocks_1 = FFX_VariableShading_NumBlocks1D_1 * FFX_VariableShading_NumBlocks1D_1;

groupshared float3 FFX_VariableShading_LdsVariance_1[FFX_VariableShading_SampleCount_1];
groupshared float FFX_VariableShading_LdsMin_1[FFX_VariableShading_SampleCount_1];
groupshared float FFX_VariableShading_LdsMax_1[FFX_VariableShading_SampleCount_1];



static const uint FFX_VariableShading_ThreadCount1D = 8;
static const uint FFX_VariableShading_NumBlocks1D = 32 / 16;
static const uint FFX_VariableShading_TilesPerGroup = FFX_VariableShading_NumBlocks1D * FFX_VariableShading_NumBlocks1D;
static const uint FFX_VariableShading_SampleCount1D = FFX_VariableShading_ThreadCount1D + 2;
//
groupshared uint FFX_VariableShading_LdsGroupReduce[FFX_VariableShading_TilesPerGroup];
//
static const uint FFX_VariableShading_ThreadCount = FFX_VariableShading_ThreadCount1D * FFX_VariableShading_ThreadCount1D;
static const uint FFX_VariableShading_SampleCount = FFX_VariableShading_SampleCount1D * FFX_VariableShading_SampleCount1D;
static const uint FFX_VariableShading_NumBlocks = FFX_VariableShading_NumBlocks1D * FFX_VariableShading_NumBlocks1D;

//// load and compute variance for 1x2, 2x1, 2x2, 2x4, 4x2, 4x4 for 8x8 coarse pixels
groupshared uint FFX_VariableShading_LdsShadingRate[FFX_VariableShading_SampleCount];


float FFX_VariableShading_GetLuminance(int2 pos)
{
int2 g_Resolution = int2(1711, 941);
   
    float2 v = FFX_VariableShading_ReadMotionVec2D(pos);
    pos = pos - round(v);
    // clamp to screen
    if (pos.x < 0) pos.x = 0;
    if (pos.y < 0) pos.y = 0;
    if (pos.x >= g_Resolution.x) pos.x = g_Resolution.x - 1;
    if (pos.y >= g_Resolution.y) pos.y = g_Resolution.y - 1;

    return FFX_VariableShading_ReadLuminance(pos);
}

int FFX_VariableShading_FlattenLdsOffset(int2 coord)
{
    coord += 1;
    return coord.y * FFX_VariableShading_SampleCount1D + coord.x;
}

int FFX_VariableShading_FlattenLdsOffset_1(int2 coord)
{
    coord += 1;
    return coord.y * FFX_VariableShading_SampleCount1D_1 + coord.x;
}

/*
//--------------------------------------------------------------------------------------//
// Main function (without additional shading rates) */                                  //
//--------------------------------------------------------------------------------------//
void FFX_VariableShading_GenerateVrsImage1(uint3 Gid, uint3 Gtid, uint Gidx)
{
    int2 g_Resolution = int2(1711, 941);
    uint g_TileSize = 16;
    //float g_VarianceCutoff = 0.05;
    //float g_MotionFactor = 0.05;

    int2 tileOffset = Gid.xy * FFX_VariableShading_ThreadCount1D_1 * 2;
    int2 baseOffset = tileOffset + int2(-2, -2);
    uint index = Gidx;


    if (index == 0)
    {
        FFX_VariableShading_LdsGroupReduce_1 = FFX_VARIABLESHADING_RATE_2X2;
    }

    // sample source texture (using motion vectors)
    while (index < FFX_VariableShading_SampleCount_1)
    {
        int2 index2D = 2 * int2(index % FFX_VariableShading_SampleCount1D_1, index / FFX_VariableShading_SampleCount1D_1);
        float4 lum = 0;
        lum.x = FFX_VariableShading_GetLuminance(baseOffset + index2D + int2(0, 0));
        lum.y = FFX_VariableShading_GetLuminance(baseOffset + index2D + int2(1, 0));
        lum.z = FFX_VariableShading_GetLuminance(baseOffset + index2D + int2(0, 1));
        lum.w = FFX_VariableShading_GetLuminance(baseOffset + index2D + int2(1, 1));

        // compute the 2x1, 1x2 and 2x2 variance inside the 2x2 coarse pixel region
        float3 delta;
        delta.x = max(abs(lum.x - lum.y), abs(lum.z - lum.w));
        delta.y = max(abs(lum.x - lum.z), abs(lum.y - lum.w));
        float2 minmax = float2(min(min(min(lum.x, lum.y), lum.z), lum.w), max(max(max(lum.x, lum.y), lum.z), lum.w));
        delta.z = minmax.y - minmax.x;

        // reduce variance value for fast moving pixels
      float v = length(FFX_VariableShading_ReadMotionVec2D(baseOffset + index2D));
      v *= PassSrg::g_MotionFactor;
      delta -= v;
      minmax.y -= v;

      // store variance as well as min/max luminance
      FFX_VariableShading_LdsVariance_1[index] = delta;
      FFX_VariableShading_LdsMin_1[index] = minmax.x;
      FFX_VariableShading_LdsMax_1[index] = minmax.y;

      index += FFX_VariableShading_ThreadCount_1;
  }

  GroupMemoryBarrierWithGroupSync();

  // upper left coordinate in LDS
  int2 threadUV = Gtid.xy;

  // look at neighbouring coarse pixels, to combat burn in effect due to frame dependence
  float3 delta = FFX_VariableShading_LdsVariance_1[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(0, 0))];

  // read the minimum luminance for neighbouring coarse pixels
  float minNeighbour = FFX_VariableShading_LdsMin_1[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(0, -1))];
  minNeighbour = min(minNeighbour, FFX_VariableShading_LdsMin_1[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(-1, 0))]);
  minNeighbour = min(minNeighbour, FFX_VariableShading_LdsMin_1[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(0, 1))]);
  minNeighbour = min(minNeighbour, FFX_VariableShading_LdsMin_1[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(1, 0))]);
  float dMin = max(0, FFX_VariableShading_LdsMin_1[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(0, 0))] - minNeighbour);

  // read the maximum luminance for neighbouring coarse pixels
  float maxNeighbour = FFX_VariableShading_LdsMax_1[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(0, -1))];
  maxNeighbour = max(maxNeighbour, FFX_VariableShading_LdsMax_1[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(-1, 0))]);
  maxNeighbour = max(maxNeighbour, FFX_VariableShading_LdsMax_1[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(0, 1))]);
  maxNeighbour = max(maxNeighbour, FFX_VariableShading_LdsMax_1[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(1, 0))]);
  float dMax = max(0, maxNeighbour - FFX_VariableShading_LdsMax_1[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(0, 0))]);

  // assume higher luminance based on min & max values gathered from neighbouring pixels
  delta = max(0, delta + dMin + dMax);

  // Reduction: find maximum variance within VRS tile

  // with tilesize=16 we compute 1 tile in one 8x8 threadgroup, in wave32 mode we'll need LDS to compute the per tile max
  // similar for tilesize=32: 1 tile is computed in a 16x16 threadgroup, so we definitely need LDS
  delta = WaveActiveMax(delta);

  if (WaveIsFirstLane())
  {
      uint shadingRate = FFX_VARIABLESHADING_MAKE_SHADING_RATE(FFX_VARIABLESHADING_RATE1D_1X, FFX_VARIABLESHADING_RATE1D_1X);

      if (delta.z < PassSrg::g_VarianceCutoff)
      {
          shadingRate = FFX_VARIABLESHADING_MAKE_SHADING_RATE(FFX_VARIABLESHADING_RATE1D_2X, FFX_VARIABLESHADING_RATE1D_2X);
      }
      else
      {
          if (delta.x > delta.y)
          {
              shadingRate = FFX_VARIABLESHADING_MAKE_SHADING_RATE(FFX_VARIABLESHADING_RATE1D_1X, (delta.y > PassSrg::g_VarianceCutoff) ? FFX_VARIABLESHADING_RATE1D_1X : FFX_VARIABLESHADING_RATE1D_2X);
          }
          else
          {
              shadingRate = FFX_VARIABLESHADING_MAKE_SHADING_RATE((delta.x > PassSrg::g_VarianceCutoff) ? FFX_VARIABLESHADING_RATE1D_1X : FFX_VARIABLESHADING_RATE1D_2X, FFX_VARIABLESHADING_RATE1D_1X);
          }
      }

      InterlockedAnd(FFX_VariableShading_LdsGroupReduce_1, shadingRate);
  }
  GroupMemoryBarrierWithGroupSync();

  if (Gidx == 0)
  {
      // Store
      FFX_VariableShading_WriteVrsImage(Gid.xy, FFX_VariableShading_LdsGroupReduce_1);
  }
}

void FFX_VariableShading_GenerateVrsImage(uint3 Gid, uint3 Gtid, uint Gidx)
{
    int2 g_Resolution = int2(1711, 941);
    uint g_TileSize = 16;
    //float g_VarianceCutoff = 0.0;
    //float g_MotionFactor = 0.05;

    int2 tileOffset = Gid.xy * FFX_VariableShading_ThreadCount1D * 4;
    int2 baseOffset = tileOffset;
    uint index = Gidx;

    while (index < FFX_VariableShading_SampleCount)
    {
        int2 index2D = 4 * int2(index % FFX_VariableShading_SampleCount1D, index / FFX_VariableShading_SampleCount1D);

        // reduce shading rate for fast moving pixels
        float v = length(FFX_VariableShading_ReadMotionVec2D(baseOffset + index2D));
        v *= PassSrg::g_MotionFactor;

        // compute variance for one 4x4 region
        float var2x1 = 0;
        float var1x2 = 0;
        float var2x2 = 0;
        float2 minmax4x2[2] = { float2(PassSrg::g_VarianceCutoff, 0.f), float2(PassSrg::g_VarianceCutoff, 0.f) };
        float2 minmax2x4[2] = { float2(PassSrg::g_VarianceCutoff, 0.f), float2(PassSrg::g_VarianceCutoff, 0.f) };
        float2 minmax4x4 = float2(PassSrg::g_VarianceCutoff, 0.f);

        // computes variance for 2x2 tiles
        // also we need min/max for 2x4, 4x2 & 4x4 
        for (uint y = 0; y < 2; y += 1)
        {
            float tmpVar4x2 = 0;
            for (uint x = 0; x < 2; x += 1)
            {
                int2 index2D = 4 * int2(index % FFX_VariableShading_SampleCount1D, index / FFX_VariableShading_SampleCount1D) + int2(2 * x, 2 * y);
                float4 lum = 0;
                lum.x = FFX_VariableShading_GetLuminance(baseOffset + index2D + int2(0, 0));
                lum.y = FFX_VariableShading_GetLuminance(baseOffset + index2D + int2(1, 0));
                lum.z = FFX_VariableShading_GetLuminance(baseOffset + index2D + int2(0, 1));
                lum.w = FFX_VariableShading_GetLuminance(baseOffset + index2D + int2(1, 1));

                float2 minmax = float2(min(min(lum.x, lum.y), min(lum.z, lum.w)), max(max(lum.x, lum.y), max(lum.z, lum.w)));
                float3 delta;
                delta.x = max(abs(lum.x - lum.y), abs(lum.z - lum.w));
                delta.y = max(abs(lum.x - lum.y), abs(lum.z - lum.w));
                delta.z = minmax.y - minmax.x;

                // reduce shading rate for fast moving pixels
                delta = max(0, delta - v);

                var2x1 = max(var2x1, delta.x);
                var1x2 = max(var1x2, delta.y);
                var2x2 = max(var2x2, delta.z);

                minmax4x2[y].x = min(minmax4x2[y].x, minmax.x);
                minmax4x2[y].y = max(minmax4x2[y].y, minmax.y);

                minmax2x4[x].x = min(minmax2x4[x].x, minmax.x);
                minmax2x4[x].y = max(minmax2x4[x].y, minmax.y);

                minmax4x4.x = min(minmax4x4.x, minmax.x);
                minmax4x4.y = max(minmax4x4.y, minmax.y);
            }
        }

        float var4x2 = max(0, max(minmax4x2[0].y - minmax4x2[0].x, minmax4x2[1].y - minmax4x2[1].x) - v);
        float var2x4 = max(0, max(minmax2x4[0].y - minmax2x4[0].x, minmax2x4[1].y - minmax2x4[1].x) - v);
        float var4x4 = max(0, minmax4x4.y - minmax4x4.x - v);

        uint shadingRate = FFX_VARIABLESHADING_RATE_1X1;
        if (var4x4 < PassSrg::g_VarianceCutoff) shadingRate = FFX_VARIABLESHADING_RATE_4X4;
        else if (var4x2 < PassSrg::g_VarianceCutoff) shadingRate = FFX_VARIABLESHADING_RATE_4X2;
        else if (var2x4 < PassSrg::g_VarianceCutoff) shadingRate = FFX_VARIABLESHADING_RATE_2X4;
        else if (var2x2 < PassSrg::g_VarianceCutoff) shadingRate = FFX_VARIABLESHADING_RATE_2X2;
        else if (var2x1 < PassSrg::g_VarianceCutoff) shadingRate = FFX_VARIABLESHADING_RATE_2X1;
        else if (var1x2 < PassSrg::g_VarianceCutoff) shadingRate = FFX_VARIABLESHADING_RATE_1X2;

        FFX_VariableShading_LdsShadingRate[index] = shadingRate;

        index += FFX_VariableShading_ThreadCount;
    }

    if (Gidx < FFX_VariableShading_TilesPerGroup)
    {
        FFX_VariableShading_LdsGroupReduce[Gidx] = 0;
    }
    GroupMemoryBarrierWithGroupSync();

    int i = 0;
    int2 threadUV = Gtid.xy;

    uint shadingRate[FFX_VariableShading_TilesPerGroup];
    for (i = 0; i < FFX_VariableShading_TilesPerGroup; ++i)
    {
        shadingRate[i] = FFX_VARIABLESHADING_RATE_4X4;
    }
    uint idx = (Gtid.y & (FFX_VariableShading_NumBlocks1D - 1)) * FFX_VariableShading_NumBlocks1D + (Gtid.x & (FFX_VariableShading_NumBlocks1D - 1));
    shadingRate[idx] = FFX_VariableShading_LdsShadingRate[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(0, 0))];
    shadingRate[idx] = min(shadingRate[idx], FFX_VariableShading_LdsShadingRate[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(0, -1))]);
    shadingRate[idx] = min(shadingRate[idx], FFX_VariableShading_LdsShadingRate[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(-1, 0))]);
    shadingRate[idx] = min(shadingRate[idx], FFX_VariableShading_LdsShadingRate[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(1, 0))]);
    shadingRate[idx] = min(shadingRate[idx], FFX_VariableShading_LdsShadingRate[FFX_VariableShading_FlattenLdsOffset(threadUV + int2(0, 1))]);

    // wave-reduce
    for (i = 0; i < FFX_VariableShading_TilesPerGroup; ++i)
    {
        shadingRate[i] = WaveActiveMin(shadingRate[i]);
    }

    
    // write out final rates
    if (Gidx < FFX_VariableShading_TilesPerGroup)
    {
        FFX_VariableShading_WriteVrsImage( Gid.xy * FFX_VariableShading_NumBlocks1D + uint2(Gidx / FFX_VariableShading_NumBlocks1D, Gidx % FFX_VariableShading_NumBlocks1D), shadingRate[Gidx] );
    }

}

//[numthreads(TILE_DIM_X, TILE_DIM_Y, 1)]
[numthreads(8, 8, 1)]
void MainCS(
    uint3 Gid  : SV_GroupID,
    uint3 Gtid : SV_GroupThreadID,
    uint  Gidx : SV_GroupIndex)
{
    //FFX_VariableShading_GenerateVrsImage1(Gid, Gtid, Gidx);
    FFX_VariableShading_GenerateVrsImage(Gid, Gtid, Gidx);
    
}